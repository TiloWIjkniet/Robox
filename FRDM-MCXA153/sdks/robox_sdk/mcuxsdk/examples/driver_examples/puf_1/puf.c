/*
 * Copyright 2018-2019, 2023 NXP.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/*******************************************************************************
 * Includes
 ******************************************************************************/

#include <stdlib.h>
#include "fsl_device_registers.h"
#include "fsl_debug_console.h"
#include "board.h"
#include "app.h"

#include "fsl_puf.h"
#include "fsl_rom_api.h"
#include "fsl_iap.h"
#include "fsl_iap_ffr.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/
#define PUF_INTRINSIC_KEY_SIZE 16

/*******************************************************************************
 * Variables
 ******************************************************************************/
/* User key in little-endian format. */
/* 32 bytes key for ECB method: "Thispasswordisveryuncommonforher". */
static const uint8_t s_userKey256[] __attribute__((aligned)) = {
    0x72, 0x65, 0x68, 0x72, 0x6f, 0x66, 0x6e, 0x6f, 0x6d, 0x6d, 0x6f, 0x63, 0x6e, 0x75, 0x79, 0x72,
    0x65, 0x76, 0x73, 0x69, 0x64, 0x72, 0x6f, 0x77, 0x73, 0x73, 0x61, 0x70, 0x73, 0x69, 0x68, 0x54};

static uint8_t activationCode[PUF_ACTIVATION_CODE_SIZE] __ALIGNED(sizeof(uint32_t));

/*******************************************************************************
 * Prototypes
 ******************************************************************************/

/*******************************************************************************
 * Code
 ******************************************************************************/

static void Error(void)
{
    while (1)
    {
        ;
    }
}

/*!
 * @brief Main function.
 */
int main(void)
{
    status_t result;
    flash_config_t flashInstance;

    uint8_t keyCode0[PUF_GET_KEY_CODE_SIZE_FOR_KEY_SIZE(32)];
    uint8_t keyCode1[PUF_GET_KEY_CODE_SIZE_FOR_KEY_SIZE(PUF_INTRINSIC_KEY_SIZE)];
    uint8_t intrinsicKey[PUF_INTRINSIC_KEY_SIZE] = {0};
    /* PUF SRAM Configuration*/
    puf_config_t conf;

    /* Init hardware */
    BOARD_InitHardware();

    PRINTF("MCUX SDK version: %s\r\n", MCUXSDK_VERSION_FULL_STR);

    /* Initialize random number generator used to generate key mask for HW key */
    /* In real application, the seed shall be obtained from a hardware random number generator. */
    srand(0xbabadeda);
    PRINTF("PUF Peripheral Driver Example\r\n\r\n");

    /* PUF_Init and PUF_Start don't need to be used here, because the bootloader has already taken care of this before
     * jumping to this application. However, the clock towards the PUF block still needs to be enabled*/
    CLOCK_EnableClock(kCLOCK_Puf);

    /* Create keycode for user key with index 0 */
    /* Index 0 selects that the key shall be ouptut (by PUF_GetHwKey()) to a SoC specific private hardware bus. */
    result = PUF_SetUserKey(PUF, kPUF_KeyIndex_00, s_userKey256, 32, keyCode0, sizeof(keyCode0));
    PRINTF("Wrapping a new key chosen by the user to PUF index 0 (will only be accessible on dedicated HW bus)\r\n");
    if (result != kStatus_Success)
    {
        PRINTF("Error setting user key!\r\n");
        Error();
    }

    /* Generate new intrinsic key with index 1 */
    result = PUF_SetIntrinsicKey(PUF, kPUF_KeyIndex_01, PUF_INTRINSIC_KEY_SIZE, keyCode1, sizeof(keyCode1));
    PRINTF("Wrapping a key generated by the PUF itself to PUF index 1 (will be accessible to SW)\r\n");
    if (result != kStatus_Success)
    {
        PRINTF("Error setting intrinsic key!\r\n");
        Error();
    }

    /* Reconstruct key from keyCode0 to HW bus for crypto module */
    result = PUF_GetHwKey(PUF, keyCode0, sizeof(keyCode0), kPUF_KeySlot0, rand());
    PRINTF(
        "Unwrapping/reconstructing the key chosen by the user, that was stored in key slot 0 of the HW bus (i.e. the "
        "slot for the AES engine), using key index 0\r\n");
    if (result != kStatus_Success)
    {
        PRINTF("Error reconstructing key to HW bus!\r\n");
        Error();
    }

    /* Reconstruct intrinsic key from keyCode1 generated by PUF_SetIntrinsicKey() */
    result = PUF_GetKey(PUF, keyCode1, sizeof(keyCode1), intrinsicKey, sizeof(intrinsicKey));
    PRINTF("Unwrapping/reconstructing the generated key using key index 1\r\n");
    if (result != kStatus_Success)
    {
        PRINTF("Error reconstructing intrinsic key!\r\n");
        Error();
    }

    PRINTF("Reconstructed intrinsic key = ");
    for (int i = 0; i < PUF_INTRINSIC_KEY_SIZE; i++)
    {
        PRINTF("%02X ", intrinsicKey[i]);
    }

    PUF_GetDefaultConfig(&conf);

    /* Deinitializing the PUF will disable its SRAM and peripheral clock */
    PUF_Deinit(PUF, &conf);
    PRINTF("\r\n\nPUF Deinitialization.\r\n");

    /* Since we have deinitialized the PUF, we need to initialize it and start it again within this app before we can
     * use it again */

    /* Initialize PUF peripheral */
    result = PUF_Init(PUF, &conf);
    PRINTF("PUF Initialization.\r\n");
    if (result != kStatus_Success)
    {
        PRINTF("Error Initializing PUF!\r\n");
        Error();
    }

    /* Init flash driver and FFR flash driver */
    result = FLASH_Init(&flashInstance);
    PRINTF("Flash Initialization.\r\n");
    if (result != kStatus_FLASH_Success)
    {
        PRINTF("Error starting flash!\r\n");
        Error();
    }

    /* We need to retrieve the Activation Code present in flash to be able to start the PUF and retrieve the wrapped
     * keys stored previously */
    result = FFR_KeystoreGetAC(&flashInstance, activationCode);
    PRINTF("Retrieving the Activation Code of the user key store.\r\n");
    if (result != kStatus_FLASH_Success)
    {
        PRINTF("Error retrieving the Activation Code of the user key store!\r\n");
        Error();
    }

    /* Start PUF by loading generated activation code */
    result = PUF_Start(PUF, activationCode, sizeof(activationCode));
    PRINTF("PUF Start with the retrieved Activation Code.\r\n");
    if (result == kStatus_StartNotAllowed)
    {
        PRINTF("Start is not allowed!\r\n");
        PRINTF("Will make powercycle and start again!\r\n");
        (void)PUF_PowerCycle(PUF, &conf);
        result = PUF_Start(PUF, activationCode, sizeof(activationCode));
        PRINTF("Retrying PUF Start with the retrieved Activation Code.\r\n");
    }

    if (result != kStatus_Success)
    {
        PRINTF("Error during Start !\r\n");
        Error();
    }

    /* Reconstruct intrinsic key again from keyCode1 generated by PUF_SetIntrinsicKey(), to prove the PUF still works */
    for (int i = 0; i < PUF_INTRINSIC_KEY_SIZE; i++)
    {
        intrinsicKey[i] = 0;
    }
    result = PUF_GetKey(PUF, keyCode1, sizeof(keyCode1), intrinsicKey, sizeof(intrinsicKey));
    PRINTF("Unwrapping/reconstructing the generated key again using key index 1\r\n");
    if (result != kStatus_Success)
    {
        PRINTF("Error reconstructing intrinsic key!\r\n");
        Error();
    }

    PRINTF("Reconstructed intrinsic key = ");
    for (int i = 0; i < PUF_INTRINSIC_KEY_SIZE; i++)
    {
        PRINTF("%02X ", intrinsicKey[i]);
    }
    PRINTF("\r\n");

    PRINTF("END OF PUF DRIVER EXAMPLE\n");

    while (1)
    {
    }
}