/*
** ###################################################################
**     Processors:          MCXW236AIHNAR
**                          MCXW236AIUKAR
**                          MCXW236BIHNAR
**                          MCXW236BIUKAR
**
**     Compiler:            IAR ANSI C/C++ Compiler for ARM
**     Reference manual:    MCXW23x User manual Rev.0.1  1 September 2022
**     Version:             rev. 1.0, 2025
**
**     Abstract:
**         Linker file for the IAR ANSI C/C++ Compiler for ARM
**
**     Copyright 2025 NXP
**     SPDX-License-Identifier: BSD-3-Clause
**
**     http:                 www.nxp.com
**     mail:                 support@nxp.com
**
** ###################################################################
*/


/* Stack and Heap Sizes */
if (isdefinedsymbol(__stack_size__)) {
  define symbol __size_cstack__        = __stack_size__;
} else {
  define symbol __size_cstack__        = 0x0D00;
}

if (isdefinedsymbol(__heap_size__)) {
  define symbol __size_heap__          = __heap_size__;
} else {
  define symbol __size_heap__          = 0x0800;
}

define symbol FLASH_START       = 0x0;
if (isdefinedsymbol(MCXW235)) {
    define symbol FLASH_SIZE        = 0x80000;
} else {
    define symbol FLASH_SIZE        = 0xFE000;
}
define symbol FLASH_END         = FLASH_START + FLASH_SIZE - 1;
define symbol FLASH_SECTOR_SIZE = 0x2000; /* 8KB */

define exported symbol NV_STORAGE_END_ADDRESS       = FLASH_END;
if (isdefinedsymbol(MCXW235)) {
    define exported symbol NV_STORAGE_MAX_SECTORS   = 2;
} else {
    define exported symbol NV_STORAGE_MAX_SECTORS   = 4;
}
define exported symbol NV_STORAGE_SECTOR_SIZE       = FLASH_SECTOR_SIZE;
define exported symbol NV_STORAGE_SIZE              = FLASH_SECTOR_SIZE * NV_STORAGE_MAX_SECTORS;
define exported symbol NV_STORAGE_START_ADDRESS     = NV_STORAGE_END_ADDRESS - NV_STORAGE_SIZE + 1;

if (isdefinedsymbol(gUseDatastoreLink_d)) {
    define exported symbol DATASTORE_SIZE           = FLASH_SECTOR_SIZE;
} else {
    define exported symbol DATASTORE_SIZE           = 0;
}
define exported symbol DATASTORE_START_ADDRESS      = NV_STORAGE_START_ADDRESS - DATASTORE_SIZE;
define exported symbol DATASTORE_END_ADDRESS        = DATASTORE_START_ADDRESS + DATASTORE_SIZE -1;

if (isdefinedsymbol(gUseEventstoreLink_d)) {
    define exported symbol EVENTSTORE_SIZE          = FLASH_SECTOR_SIZE*2;
} else {
    define exported symbol EVENTSTORE_SIZE          = 0;
}
define exported symbol EVENTSTORE_START_ADDRESS     = DATASTORE_START_ADDRESS - EVENTSTORE_SIZE;
define exported symbol EVENTSTORE_END_ADDRESS       = EVENTSTORE_START_ADDRESS + EVENTSTORE_SIZE -1;

define exported symbol INT_STORAGE_END              = EVENTSTORE_START_ADDRESS - 1;
if(isdefinedsymbol(gUseInternalStorageLink_d)) {
    define exported symbol INT_STORAGE_SIZE = FLASH_SECTOR_SIZE * ( ( (INT_STORAGE_END + 1 - FLASH_START) / 2 ) / FLASH_SECTOR_SIZE + 1);
}
else {
    define exported symbol INT_STORAGE_SIZE = 0;
}
define exported symbol INT_STORAGE_START            = INT_STORAGE_END - INT_STORAGE_SIZE + 1;
define exported symbol INT_STORAGE_SECTOR_SIZE      = FLASH_SECTOR_SIZE;

define symbol m_interrupts_start               = FLASH_START;
define symbol m_interrupts_size                = 0x00000200;
define symbol m_interrupts_end                 = m_interrupts_start + m_interrupts_size - 1;

define symbol m_text_start                     = m_interrupts_end + 1;
define symbol m_text_end                       = INT_STORAGE_START - 1;

define symbol m_data_start                     = 0x20004000;
if (isdefinedsymbol(MCXW235)) {
    define symbol m_data_size                  = 0x14000;
} else {
    define symbol m_data_size                  = 0x1C000;
}
define symbol m_data_end                       = m_data_start + m_data_size - 1;

define exported symbol __VECTOR_TABLE          = m_interrupts_start;
define exported symbol __RAM_VECTOR_TABLE_SIZE = 0x00000140;

define symbol LAST_HEAP_ADDRESS = m_data_end; /* Needs to be known to calculate __HEAP_end__ below */
define exported symbol __HEAP_end__             = LAST_HEAP_ADDRESS - __size_cstack__;

define memory mem with size = 4G;

define region VECT_region   = mem:[from m_interrupts_start to m_interrupts_end];
define region TEXT_region   = mem:[from m_text_start to m_text_end];
define region DATA_region   = mem:[from m_data_start to m_data_end-__size_cstack__];
define region CSTACK_region = mem:[from m_data_end - __size_cstack__ + 1 to m_data_end];

define block CSTACK    with alignment = 8, size = __size_cstack__   { };
define block HEAP      with alignment = 8 { section .heap };
define block RW        { readwrite };
define block ZI        { zi };
define block RAMFUNC   { section .ramfunc };

initialize by copy {
    readwrite,
    readonly object fsl_spifi.o,
    section .textrw,
    section .ramfunc
};

if (isdefinedsymbol(__USE_DLIB_PERTHREAD))
{
  /* Required in a multi-threaded application */
  initialize by copy with packing = none { section __DLIB_PERTHREAD };
}

do not initialize  { section .noinit };
do not initialize  { section .heap };

place at address mem: m_interrupts_start    { readonly section .intvec };
place in TEXT_region                        { readonly };
place in DATA_region                        { block RW };
place in DATA_region                        { block ZI };
place in DATA_region                        { block RAMFUNC };
place in DATA_region                        { last block HEAP };
place in CSTACK_region                      { block CSTACK };
